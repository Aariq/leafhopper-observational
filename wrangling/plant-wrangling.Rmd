---
title: "Plant growth data wrangling"
author: "Eric R. Scott"
date: "2019-11-5"
output: 
  html_notebook: 
    highlight: kate
    theme: yeti
    toc: yes
    toc_float: yes
    number_sections: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

*Last compiled: `r Sys.Date()`*

```{r packages, message=FALSE, warning=FALSE}
library(tidyverse)
library(here)
library(lubridate)
library(conflicted)
conflict_prefer("filter", "dplyr")
conflict_prefer("lag", "dplyr")
conflict_prefer("here", "here")
```

#Purpose

gathering of shoots by plant and date, and reading in of stem diameter data done in the shoot growth script. One challenge is that every inter-harvest period the shoots are re-set.  That limits me from using all the data easily.  The way I'm thinking of dealing with this is to separate the data into fields and harvest periods, calculate relative growth rates, match them to daily temperatures, and then re-combine the data for modeling.

```{r}
growth <- read_rds(here("data", "cleaned", "shoot-growth.rds"))
diameter <- read_rds(here("data", "cleaned", "shoot-diameter.rds"))
hobo <- read_rds(here("data", "cleaned", "daily-temps-hobo.rds"))
caas <- read_rds(here("data", "cleaned", "weather-caas.rds"))
rain_gauge <- read_rds(here("data", "cleaned", "rain-gauge.rds"))
caas_sub <-
  caas %>% 
    select(date, precip_caas = precip_caas_0.1mm, sun_hrs, rh)
```

### Read in data and split by field
Load data, separate fields A and B
```{r, message=TRUE, warning=TRUE}
input.A <- growth %>% filter(field == "A")
input.B <- growth %>% filter(field == "B")
```

### Split by inter-harvest period

#### Extract harvest dates and create inter-harvest intervals
Find harvest dates for both fields
```{r find harvest dates}
#Find the harvest dates, i.e. the first date of each inter-harvest period.

harvest.dates.A <- input.A %>% 
  group_by(date) %>% 
  summarise(Harvest = last(harvest)) %>% 
  filter(Harvest == "Y") %>% 
  ungroup() %>% 
  select(date)

harvest.dates.B <- input.B %>% 
  group_by(date) %>% 
  summarise(Harvest = last(harvest)) %>% 
  filter(Harvest == "Y") %>% 
  ungroup() %>% 
  select(date)

harvest.dates.B <- add_row(harvest.dates.B, date = max(input.B$date) + days(1))
#on the last day of data collection field B was harvested
```

Create harvest intervals.  Intervals are a data format from the `lubridate` package.  Because of the way I've coded harvesting, the last date of each inter-harvest interval is the harvest date - 1 day.
```{r create harvest intervals}
harvest.int.A <- (lag(harvest.dates.A$date) - days(1)) %--% (harvest.dates.A$date - days(1))
harvest.int.A <- harvest.int.A[-1]

harvest.int.B <- (lag(harvest.dates.B$date) - days(1)) %--% (harvest.dates.B$date - days(1))

#the very first day of data collection was not immediately after a harvest.  Add that interval manually.

harvest.int.B[1] <- min(input.B$date) %--% (harvest.dates.B$date[1] - days(1))
```

Ok, now I create a column showing which interharvest period each datapoint belongs to labeled by harvest date and another column labeled by harvest number (1-4)
```{r assign intervals}
data.A <-
  input.A %>%
  mutate(interharvest = case_when(date %within% harvest.int.A[1] ~ int_end(harvest.int.A[1]),
                                  date %within% harvest.int.A[2] ~ int_end(harvest.int.A[2]),
                                  date %within% harvest.int.A[3] ~ int_end(harvest.int.A[3]),
                                  date %within% harvest.int.A[4] ~ int_end(harvest.int.A[4]),
                                  TRUE                           ~ as.POSIXct(NA)),
         interharvest.no = case_when(date %within% harvest.int.A[1] ~ 1,
                                     date %within% harvest.int.A[2] ~ 2,
                                     date %within% harvest.int.A[3] ~ 3,
                                     date %within% harvest.int.A[4] ~ 4,
                                     TRUE                           ~ as.numeric(NA)) %>% as.factor())

# Field A data collection ended before field B.  Now that these data frames are split, data.A has a bunch of NAs.  I'll get rid of them, although I'll need to remember this when re-joining the data.

data.A <- data.A %>% filter(date < ymd("2017-07-22"))

data.B <- input.B %>%
  mutate(interharvest = case_when(date %within% harvest.int.B[1] ~ int_end(harvest.int.B[1]),
                                  date %within% harvest.int.B[2] ~ int_end(harvest.int.B[2]),
                                  date %within% harvest.int.B[3] ~ int_end(harvest.int.B[3]),
                                  date %within% harvest.int.B[4] ~ int_end(harvest.int.B[4]),
                                  TRUE                           ~ as.POSIXct(NA)),
         interharvest.no = case_when(date %within% harvest.int.B[1] ~ 1,
                                     date %within% harvest.int.B[2] ~ 2,
                                     date %within% harvest.int.B[3] ~ 3,
                                     date %within% harvest.int.B[4] ~ 4,
                                     TRUE                           ~ as.numeric(NA)) %>% as.factor())
```

Now I group by interhavest period and calculate a growth rate for each shoot on each day.

Absolute growth rate:
$$
AGR = \frac{S_2 - S_1}{t_2 - t_1}
$$
```{r}
data.B.full <- 
  data.B %>% 
  mutate(shoot = paste0("f", field, "-h", interharvest.no, "-p", plant, "-s", shoot)) %>% 
  group_by(interharvest, shoot) %>% 
  arrange(date) %>% 
  mutate(growth = shoot_height - lag(shoot_height))

data.A.full <- 
  data.A %>% 
  mutate(shoot = paste0("f", field, "-h", interharvest.no, "-p", plant, "-s", shoot)) %>% 
  group_by(interharvest, shoot) %>% 
  arrange(date) %>% 
  mutate(growth = shoot_height - lag(shoot_height))
```


### Join with weather data
read in temperature data and join with field A and B data.  Because shoot measurements are taken early in the morning, its the temperature of the previous day that is most relevant.  I create an "effective date" to allow easy merging of the two data sources.

```{r}
data.B.wtemp <-
  left_join(data.B.full, hobo, by = "date") 
data.B.weather <-
  left_join(data.B.wtemp, caas_sub, by = "date")
data.B.weather2 <-
  left_join(data.B.weather, rain_gauge, by = "date")

data.A.wtemp <-
  left_join(data.A.full, hobo, by = "date") 
data.A.weather <-
  left_join(data.A.wtemp, caas_sub, by = "date")
data.A.weather2 <-
  left_join(data.A.weather, rain_gauge, by = "date")
```



### Join with stem diameter data

Now the trick is joining it to the rest of the data correctly. Since the date the stem diameter was measured on isn't the first day of measurements always, I should do the same interharvest thing I did before and join by that column.  FIRST, I have to split by field in order to do that.

```{r}
dia.data.A <-
  diameter %>% 
  filter(field == "A") %>%
  mutate(interharvest = case_when(date %within% harvest.int.A[1] ~ int_end(harvest.int.A[1]),
                                  date %within% harvest.int.A[2] ~ int_end(harvest.int.A[2]),
                                  date %within% harvest.int.A[3] ~ int_end(harvest.int.A[3]),
                                  date %within% harvest.int.A[4] ~ int_end(harvest.int.A[4]),
                                  TRUE                           ~ as.POSIXct(NA)),
         interharvest.no = case_when(date %within% harvest.int.A[1] ~ 1,
                                     date %within% harvest.int.A[2] ~ 2,
                                     date %within% harvest.int.A[3] ~ 3,
                                     date %within% harvest.int.A[4] ~ 4,
                                     TRUE                           ~ as.numeric(NA)) %>% as.character())

dia.data.B <- 
  diameter %>%
  filter(field == "B") %>% 
  mutate(interharvest = case_when(date %within% harvest.int.B[1] ~ int_end(harvest.int.B[1]),
                                  date %within% harvest.int.B[2] ~ int_end(harvest.int.B[2]),
                                  date %within% harvest.int.B[3] ~ int_end(harvest.int.B[3]),
                                  date %within% harvest.int.B[4] ~ int_end(harvest.int.B[4]),
                                  TRUE                           ~ as.POSIXct(NA)),
         interharvest.no = case_when(date %within% harvest.int.B[1] ~ 1,
                                     date %within% harvest.int.B[2] ~ 2,
                                     date %within% harvest.int.B[3] ~ 3,
                                     date %within% harvest.int.B[4] ~ 4,
                                     TRUE                           ~ as.numeric(NA)) %>% as.character())
#merge it back together and overwrite
dia.data <- bind_rows(dia.data.A, dia.data.B)
#so actually the date I measured stem diameter doesn't matter
dia.data2 <-
  dia.data %>% 
  mutate(shoot = paste0("f", field, "-h", interharvest.no, "-p", plant, "-s", shoot)) %>% 
  select(-date)
dia.data2 %>% arrange(interharvest)
```

Now I can join it with the shoot data
```{r}
shoot.data <- 
  bind_rows(left_join(data.A.full, dia.data.A),
            left_join(data.B.full, dia.data.B))
```

# Add weather data

```{r}
shoot_data_full <-
  left_join(shoot.data, hobo, by = "date") %>% 
  left_join(caas_sub, by = "date") %>% 
  left_join(rain_gauge, by = "date")
```


### Export shoot growth data
```{r}
write_rds(shoot_data_full, here("data", "cleaned", "shoots.rds"))
```