---
title: "Plant growth data wrangling"
author: "Eric R. Scott"
date: "2019-11-5"
output: 
  html_notebook: 
    highlight: kate
    theme: yeti
    toc: yes
    toc_float: yes
    number_sections: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

*Last compiled: `r Sys.Date()`*

```{r packages, message=FALSE, warning=FALSE}
library(tidyverse)
library(here)
library(lubridate)
library(conflicted)
conflict_prefer("filter", "dplyr")
conflict_prefer("lag", "dplyr")
conflict_prefer("here", "here")
```

# Purpose

gathering of shoots by plant and date, and reading in of stem diameter data done in the shoot growth script. One challenge is that every inter-harvest period the shoots are re-set.  That's why in some places I've split by field and then recombined.

# Read in data
```{r}
growth <- read_rds(here("data", "cleaned", "shoot-growth.rds"))
diameter <- read_rds(here("data", "cleaned", "shoot-diameter.rds"))
hobo <- read_rds(here("data", "cleaned", "daily-temps-hobo.rds"))
caas <- read_rds(here("data", "cleaned", "weather-caas.rds"))
rain_gauge <- read_rds(here("data", "cleaned", "rain-gauge.rds"))
caas_sub <-
  caas %>% 
    select(date, precip_caas_mm, temp_mean_caas, temp_max_caas, temp_min_caas, sun_hrs, rh) %>% 
  filter(year(date) == 2017)
```

`growth`: field data including plant growth and leafhopper densities
`diameter`: stem diameters taken once per harvest
`hobo`: daily summary of datalogger temps
`rain_gauge`: precipitation data from a rain gauge that I installed on the farm.  This record is incomplete, as the shipping of the rain gauge was delayed.
`caas`: weather station data.  Note: already checked that temperature matches the datalogger well, and precipitation matches rain gauge OK (significantly correlated, but some discrepancies in ammount of precip).


Separate fields A and B

```{r, message=TRUE, warning=TRUE}
input.A <- growth %>% filter(field == "A")
input.B <- growth %>% filter(field == "B")
```

# Create inter-harvest periods

Find harvest dates for both fields

```{r find harvest dates}
#Find the harvest dates, i.e. the first date of each inter-harvest period.

harvest.dates.A <-
  input.A %>% 
  group_by(date) %>% 
  summarise(Harvest = last(harvest)) %>% 
  filter(Harvest == "Y") %>% 
  ungroup() %>% 
  select(date)

harvest.dates.B <- input.B %>% 
  group_by(date) %>% 
  summarise(Harvest = last(harvest)) %>% 
  filter(Harvest == "Y") %>% 
  ungroup() %>% 
  select(date)

harvest.dates.B <- add_row(harvest.dates.B, date = max(input.B$date) + days(1))
#on the last day of data collection field B was harvested
```

Create harvest intervals.  Intervals are a data format from the `lubridate` package.  Because of the way I've coded harvesting, the last date of each inter-harvest interval is the harvest date - 1 day.

```{r create harvest intervals}
harvest.int.A <- (lag(harvest.dates.A$date) - days(1)) %--% (harvest.dates.A$date - days(1))
harvest.int.A <- harvest.int.A[-1]

harvest.int.B <- (lag(harvest.dates.B$date) - days(1)) %--% (harvest.dates.B$date - days(1))

#the very first day of data collection was not immediately after a harvest.  Add that interval manually.

harvest.int.B[1] <- min(input.B$date) %--% (harvest.dates.B$date[1] - days(1))
```

Ok, now I create a column showing which interharvest period each datapoint belongs to labeled by harvest date and another column labeled by harvest number (1-4)

```{r assign intervals}
data.A <-
  input.A %>%
  mutate(interharvest = case_when(date %within% harvest.int.A[1] ~ int_end(harvest.int.A[1]),
                                  date %within% harvest.int.A[2] ~ int_end(harvest.int.A[2]),
                                  date %within% harvest.int.A[3] ~ int_end(harvest.int.A[3]),
                                  date %within% harvest.int.A[4] ~ int_end(harvest.int.A[4]),
                                  TRUE                           ~ as.POSIXct(NA)),
         interharvest.no = case_when(date %within% harvest.int.A[1] ~ 1,
                                     date %within% harvest.int.A[2] ~ 2,
                                     date %within% harvest.int.A[3] ~ 3,
                                     date %within% harvest.int.A[4] ~ 4,
                                     TRUE                           ~ as.numeric(NA)) %>% as.factor())

# Field A data collection ended before field B.  Now that these data frames are split, data.A has a bunch of NAs.  I'll get rid of them, although I'll need to remember this when re-joining the data.

data.A <- data.A %>% filter(date < ymd("2017-07-22"))

data.B <- input.B %>%
  mutate(interharvest = case_when(date %within% harvest.int.B[1] ~ int_end(harvest.int.B[1]),
                                  date %within% harvest.int.B[2] ~ int_end(harvest.int.B[2]),
                                  date %within% harvest.int.B[3] ~ int_end(harvest.int.B[3]),
                                  date %within% harvest.int.B[4] ~ int_end(harvest.int.B[4]),
                                  TRUE                           ~ as.POSIXct(NA)),
         interharvest.no = case_when(date %within% harvest.int.B[1] ~ 1,
                                     date %within% harvest.int.B[2] ~ 2,
                                     date %within% harvest.int.B[3] ~ 3,
                                     date %within% harvest.int.B[4] ~ 4,
                                     TRUE                           ~ as.numeric(NA)) %>% as.factor())

```


Now I group by interhavest period and calculate a growth rate for each shoot on each day.

Preliminary analysis leads me to believe a linear growth rate is best ($h_2 - h_1$), but I'll also calculate a geometric growth rate ($r = h_2/h_1$)

```{r}
data.B.full <- 
  data.B %>% 
  mutate(shoot_id = paste0("f", field, "-h", interharvest.no, "-p", plant, "-s", shoot)) %>% 
  group_by(interharvest, shoot_id) %>% 
  arrange(date) %>% 
  mutate(growth = shoot_height - lag(shoot_height),
         r = shoot_height/lag(shoot_height))

data.A.full <- 
  data.A %>% 
  mutate(shoot_id = paste0("f", field, "-h", interharvest.no, "-p", plant, "-s", shoot)) %>% 
  group_by(interharvest, shoot_id) %>% 
  arrange(date) %>% 
  mutate(growth = shoot_height - lag(shoot_height),
         r = shoot_height/lag(shoot_height))
```


# Join with stem diameter data

Now the trick is joining it to the rest of the data correctly. Since the date the stem diameter was measured on isn't the first day of measurements always, I should do the same interharvest thing I did before and join by that column.  FIRST, I have to split by field in order to do that.

```{r}
dia.data.A <-
  diameter %>% 
  filter(field == "A") %>%
  mutate(interharvest = case_when(date %within% harvest.int.A[1] ~ int_end(harvest.int.A[1]),
                                  date %within% harvest.int.A[2] ~ int_end(harvest.int.A[2]),
                                  date %within% harvest.int.A[3] ~ int_end(harvest.int.A[3]),
                                  date %within% harvest.int.A[4] ~ int_end(harvest.int.A[4]),
                                  TRUE                           ~ as.POSIXct(NA)),
         interharvest.no = case_when(date %within% harvest.int.A[1] ~ 1,
                                     date %within% harvest.int.A[2] ~ 2,
                                     date %within% harvest.int.A[3] ~ 3,
                                     date %within% harvest.int.A[4] ~ 4,
                                     TRUE                           ~ as.numeric(NA)) %>% as.character())
```


```{r}
dia.data.B <- 
  diameter %>%
  filter(field == "B") %>% 
  mutate(interharvest = case_when(date %within% harvest.int.B[1] ~ int_end(harvest.int.B[1]),
                                  date %within% harvest.int.B[2] ~ int_end(harvest.int.B[2]),
                                  date %within% harvest.int.B[3] ~ int_end(harvest.int.B[3]),
                                  date %within% harvest.int.B[4] ~ int_end(harvest.int.B[4]),
                                  TRUE                           ~ as.POSIXct(NA)),
         interharvest.no = case_when(date %within% harvest.int.B[1] ~ 1,
                                     date %within% harvest.int.B[2] ~ 2,
                                     date %within% harvest.int.B[3] ~ 3,
                                     date %within% harvest.int.B[4] ~ 4,
                                     TRUE                           ~ as.numeric(NA)) %>% as.character())

```


```{r}
#merge it back together and overwrite
dia.data <- bind_rows(dia.data.A, dia.data.B)
#so actually the date I measured stem diameter doesn't matter
dia.data2 <-
  dia.data %>% 
  mutate(shoot_id = paste0("f", field, "-h", interharvest.no, "-p", plant, "-s", shoot)) %>% 
  select(shoot_id, diameter)
```

Now I can join it with the shoot data

```{r}
shoot.data <- bind_rows(data.A.full, data.B.full) %>% left_join(dia.data2)
```

# Add weather data
First, I'll join the weather station data to the hobo data to extrapolate temperature data backwards in time.  Preliminary analysis showed that the temperature matched well between the hobo logger and the CAAS weather data.  Precipitation, however, did not match.

```{r}
temperature <-
  full_join(caas_sub, hobo) %>% 
    mutate(temp_mean = ifelse(is.na(temp_mean), temp_mean_caas, temp_mean),
         temp_max = ifelse(is.na(temp_max), temp_max_caas, temp_max),
         temp_min = ifelse(is.na(temp_min), temp_min_caas, temp_min)) %>% 
    arrange(date) %>% 
    select(-matches("caas"))
```

~~Now I'll do the same for the precip data~~

I'll just use the CAAS weather station precip data.  It's correlated to the rain gauge data, but covers a longer time span.  It seems like all the CAAS precip data is higher than the rain gauge, so I'll just use it instead of prepending the rain gauge data.

```{r}
# precip <-
#   full_join(caas_sub, rain_gauge) %>% 
#   mutate(precip_mm = ifelse(is.na(precip_mm), precip_caas_mm, precip_mm)) %>% 
#   arrange(date) %>% 
#   select(date, precip_mm)
precip <-
  caas_sub %>% 
  select(date, "precip_mm" = precip_caas_mm) %>% 
  arrange(date)
```

join modified weather data now

```{r}
weather <- full_join(temperature, precip, by = "date") %>% arrange(date)

temp_lags <- map_dfc(1:14, ~lag(weather$temp_mean, .x)) %>% set_names(glue::glue("temp_lag{1:14}"))
precip_lags <- map_dfc(1:14, ~lag(weather$precip_mm, .x)) %>% set_names(glue::glue("precip_lag{1:14}"))

weather_lags <- bind_cols(weather, temp_lags, precip_lags) %>% 
  select(date, starts_with("temp_"), starts_with("precip_"))
```

## Add dates for all shoots and join

```{r}
shoot_data_joined <-
  full_join(shoot.data, weather_lags, by = "date") %>% 
  arrange(date)

# prevweather<-
#   weather %>% 
#   filter(date < min(shoot.data$date)) 
# 
# shoot_data_full <-
#   shoot_data_joined %>%
#   group_by(shoot_id) %>% 
#   group_modify(~bind_rows(., prevweather)) %>% 
#   arrange(shoot_id, date)
shoot_data_full <- shoot_data_joined %>% select(-temp_max, -temp_min)
```

```{r}
shoot_data_full
```

## Pre-treatment
1. Create variable for # days post harvest and variable for start date.

```{r}
shoot.data2 <-
  shoot_data_full %>%
  group_by(shoot_id) %>% 
  mutate(day_post = day - min(day, na.rm = TRUE),
         start = min(day, na.rm = TRUE),
         mean_day = mean(day, na.rm = TRUE)) %>%
  ungroup()

# shoot.data3 %>% filter(day_post ==0) %>% group_by(field) %>% count(interharvest.no)
```

3. create unique IDs for plant and interharvest number nested within field

```{r}
shoot.data3 <-
  shoot.data2 %>% 
  mutate(plant_id = paste0(field, plant),
         interharvest_id = paste0(field, interharvest.no)) 
```

4. Remove first interharvest period for field B.  It was only 4 days, so I think data collection started in the middle of an interharvest period, making `day_post` unreliable as a co-variate for this replicate.

```{r}
shoot.data4 <- shoot.data3 %>% filter(interharvest_id != "B1")
```


6. Create lagged temperature variables

```{r}
# shoot.data5 <-
#   shoot.data4 %>%
#   select(date, shoot_id, growth, diameter, temp_mean, precip_mm, day_post, mean_day, interharvest_id) %>% 
#   group_by(shoot_id) %>% 
#   arrange(date) %>% 
#   mutate(temp_lag1 = lag(temp_mean),
#          temp_lag2 = lag(temp_mean, n = 2L),
#          temp_lag3 = lag(temp_mean, n = 3L),
#          temp_lag4 = lag(temp_mean, n = 4L),
#          temp_lag5 = lag(temp_mean, n = 5L)) %>% 
#   mutate(precip_lag1 = lag(precip_mm, n = 1L),
#          precip_lag2 = lag(precip_mm, n = 2L),
#          precip_lag3 = lag(precip_mm, n = 3L),
#          precip_lag4 = lag(precip_mm, n = 4L),
#          precip_lag5 = lag(precip_mm, n = 5L))
shoot.data5 <- shoot.data4
```

5. Remove outliers
```{r}
shoot.data6 <-
  shoot.data5 %>%
  filter(is.na(growth) | !growth > 5 & !growth < -5) 
```

7. Remove NAs
```{r}
shoot.data7 <- 
  shoot.data6 %>% 
  filter(!is.na(growth)) %>% 
  filter(!is.na(diameter))

shootdf <- shoot.data7 %>%
  select(
    date,
    shoot_id,
    interharvest_id,
    growth,
    diameter,
    day_post,
    mean_day,
    starts_with("temp"),
    starts_with("precip")
  ) %>%
  ungroup()
```
```{r}
shootdf
skimr::skim(shootdf %>% ungroup())
```

# Export Data

## Export shoot growth data
```{r}
write_rds(shootdf, here("data", "cleaned", "shoots.rds"))
```

## Weather lag data

```{r}
write_rds(weather_lags, here("data", "cleaned", "weather_lags.rds"))
```

