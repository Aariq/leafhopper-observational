---
title: "Leafhopper distributed lag model"
author: "Eric R. Scott"
date: "2020-01-25"
output: 
  html_notebook: 
    highlight: kate
    theme: yeti
    toc: yes
    toc_float: yes
    number_sections: yes
---
#TODO

- Tidy up analysis
- export figures


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(scipen = 4)
```

*Last compiled: `r Sys.Date()`*

```{r packages, message=FALSE, warning=FALSE}
library(tidyverse)
library(here)
library(conflicted)
library(mgcv)
library(dlnm)
library(colorspace)
library(cowplot)

conflict_prefer("filter", "dplyr")
conflict_prefer("here", "here")
conflict_prefer("lag", "dplyr")
conflict_prefer("select", "dplyr")
```

# Functions
```{r}
mean_matrix <- function(m, nrow){
  m_new <- m %>% 
    colMeans() %>%
    matrix(ncol = ncol(m), nrow = nrow, byrow = TRUE)
  colnames(m_new) <- colnames(m)
  return(m_new)
}
```

# Goal

This analysis is based on Gasparrini A, Scheipl F, Armstrong B, Kenward MG (2017) A penalized framework for distributed lag non-linear models. Biometrics 73:938–948. doi: 10.1111/biom.12645.  Specifically, it is based on `ex1_01.int.R` provided in their code.  This "internal" method for distributed lag models takes full(?) advantage of built in features of `gam`s.

The goal is to model the effects of temperature and precipitation on leafhoppers as having a quadratic, lagged effect.  The lag is modeled as a penalized cubic regression spline and the effect of temperature as a 2nd order polynomial in a crossbasis smoother. In an ideal world, the penalized spline would be the shrinkage version (bs = "cs"), but that isn't available in the crossbasis smooth constructor provided by `dlnm`.

# Read in Data

```{r}
hoppers <- read_rds(here("data", "cleaned", "hopper-weather.rds"))

hoppers <- hoppers %>% 
  mutate(interharvest_id = as.factor(paste0(field, interharvest.no)),
         counter = as.factor(counter),
         plant = as.factor(plant)) %>% 
  filter(!is.na(precip_lag15)) #get rid of plants that don't have 15 days of data

head(hoppers)
# str(hoppers)
```


# Distributed Lag Model: "internal" method

## Setup

Create matrices for temperature, precip, and lag.

```{r}
Q_temp <-
  hoppers %>% 
  select(starts_with("temp"), -temp_at_count, -temp_max, -temp_min) %>% 
  as.matrix()

Q_precip <-
  hoppers %>%
  select(starts_with("precip")) %>% 
  as.matrix()

L <- matrix(0:(ncol(Q_temp)-1), nrow(Q_temp), ncol(Q_temp), byrow = TRUE)
```

# Build the GAMs


```{r}
m_hopper <- 
  gam(hoppers ~
        s(Q_temp, L,
          bs = "cb",
          k = c(5, 7),
          xt = list(bs = "cr")
        ) +
        s(Q_precip, L,
          bs = "cb",
          k = c(5, 7),
          xt = list(bs = "cr")
        ) +
        s(day, bs = "cs") +
        s(day_post, bs = "cs") +
        s(counter, bs = "re") + #no difference with random vs. fixed
        s(interharvest_id, bs = "re") +
        s(plant, bs = "re"),
      family = poisson(),
      offset = log(n_leaves),
      data = hoppers,
      # gamma = 1.2, #values above 1 make smoother.  Borrowed from Teller et al.
      method = "REML")
beepr::beep(3)
```

```{r}
gam.check(m_hopper)
```
```{r}
concurvity(m_hopper)
# concurvity(m_hopper, full = FALSE)
```

Temp and precip are highly concurve, so can't trust p-values. I'll do the models separately.


```{r}
m_hopper_temp <- 
  gam(hoppers ~
        s(Q_temp, L,
          bs = "cb",
          k = c(5, 7),
          xt = list(bs = "cr")
        ) +
        s(day, bs = "cs") +
        s(day_post, bs = "cs") +
        s(counter, bs = "re") + #no difference with random vs. fixed
        s(interharvest_id, bs = "re") +
        s(plant, bs = "re"),
      family = poisson(),
      offset = log(n_leaves),
      data = hoppers,
      # gamma = 1.2, #values above 1 make smoother.  Borrowed from Teller et al.
      method = "REML")

m_hopper_precip <- 
  gam(hoppers ~
        s(Q_precip, L,
          bs = "cb",
          k = c(5, 7),
          xt = list(bs = "cr")
        ) +
        s(day, bs = "cs") +
        s(day_post, bs = "cs") +
        s(counter, bs = "re") + #no difference with random vs. fixed
        s(interharvest_id, bs = "re") +
        s(plant, bs = "re"),
      family = poisson(),
      offset = log(n_leaves),
      data = hoppers,
      # gamma = 1.2, #values above 1 make smoother.  Borrowed from Teller et al.
      method = "REML")

beepr::beep(3)
```
```{r}
AIC(m_hopper_temp, m_hopper_precip)
bbmle::ICtab(m_hopper_temp, m_hopper_precip)
```

Precip model wins.

# Temperature

## Inspect the GAM

```{r}
gam.check(m_hopper_temp)
#check for overdispersion
sum(residuals(m_hopper_temp, type = "pearson")^2) / df.residual(m_hopper_temp)
```

not overdispersed

```{r}
concurvity(m_hopper_temp, full = TRUE)
# concurvity(m_hopper_temp, full = FALSE)
```

Day and temperature have high concurvity.  They are highly correlated, but correlations breaks down quickly through lag time  I'm going to include both.


## Significance test

```{r}
anova.gam(m_hopper_temp)
```
Significant effect of plant (parametric factor), temperature, precip, days post harvest, and diameter on growth.

## Predictions and plots

### Plot regular smooths

```{r}
plot(m_hopper_temp, pages = 1, residuals = FALSE)
```

### Partial effects plot for cross-basis function

#### Make newdata

```{r}
m_hopper_temp
testvals <- seq(min(Q_temp), max(Q_temp), 0.1)

Q_temp_new <- mean_matrix(Q_temp, length(testvals))
L_new <- mean_matrix(L, length(testvals))
day_post_new <- rep(mean(hoppers$day_post), length(testvals))
day_new <- rep(mean(hoppers$day), length(testvals))
interharvest_id_new <- rep("newlevel", length(testvals))
plant_new <- rep("newlevel", length(testvals))
counter_new <- rep("newlevel", length(testvals))
```

#### predict loops

```{r}
resp_t <- array(dim = c(length(testvals), ncol(Q_temp_new)))
rownames(resp_t) <- testvals

#loop through columns of matrix, replace with testvals, predict fitted.
for(i in 1:ncol(Q_temp_new)) {
  P1_i <- Q_temp_new
  P1_i[, i] <- testvals
  resp_t[, i] <-
    suppressWarnings( #new levels of random effects are on purpose
      predict(
        m_hopper_temp,
        newdata = list(
          Q_temp = P1_i,
          L = L_new,
          day_post = day_post_new,
          day = day_new,
          interharvest_id = interharvest_id_new,
          plant = plant_new,
          counter = counter_new
        ),
        type = "response"
      )
    )
}
```

#### Make the plot

```{r}
ht_pd <-
  resp_t %>% 
  as_tibble(rownames = "x") %>% 
  pivot_longer(cols = starts_with("V"), names_to = "lag", names_prefix = "V", values_to = "fitted") %>% 
  mutate(lag = as.double(lag) - 1, x = as.double(x)) 

hopper_temp_contour <-
  ggplot(ht_pd, aes(x = x, y = lag, z = fitted, fill = fitted)) +
  geom_raster(interpolate = TRUE) +
  geom_contour(color = "black", alpha = 0.2) +
  scale_fill_viridis_c("Leafhoppers per leaf", option = "D") + 
  scale_y_continuous("Lag (days)", expand = c(0,0)) + 
  scale_x_continuous("Temperature (ºC)", expand = c(0,0)) +
  theme(text = element_text(size = 14))
save_plot(here("figs", "hopper_temp_contour.png"), hopper_temp_contour)
```


Cooler temperatures are good for leafhoppers.  Little discernable effect of lag.  Not sure how to interpret


# Precip

```{r}
gam.check(m_hopper_precip)
```
```{r}
concurvity(m_hopper_precip)
# concurvity(m_hopper_precip, full = FALSE)
```


```{r}
anova.gam(m_hopper_precip)
```

significant effect of precip, but not of date.

```{r}
plot(m_hopper_precip)
```


### Partial effects plot for cross-basis function

#### Make newdata

```{r}
m_hopper_precip
testvals <- seq(min(Q_precip), max(Q_precip), 0.1)

Q_precip_new <- mean_matrix(Q_precip, length(testvals))
L_new <- mean_matrix(L, length(testvals))
day_post_new <- rep(mean(hoppers$day_post), length(testvals))
day_new <- rep(mean(hoppers$day), length(testvals))
interharvest_id_new <- rep("newlevel", length(testvals))
plant_new <- rep("newlevel", length(testvals))
counter_new <- rep("newlevel", length(testvals))
```

#### predict loops

```{r}
resp_p <- array(dim = c(length(testvals), ncol(Q_precip_new)))
rownames(resp_p) <- testvals

#loop through columns of matrix, replace with testvals, predict fitted.
for(i in 1:ncol(Q_precip_new)) {
  P1_i <- Q_precip_new
  P1_i[, i] <- testvals
  resp_p[, i] <-
    suppressWarnings( #new levels of random effects are on purpose
      predict(
        m_hopper_precip,
        newdata = list(
          Q_precip = P1_i,
          L = L_new,
          day_post = day_post_new,
          day = day_new,
          interharvest_id = interharvest_id_new,
          plant = plant_new,
          counter = counter_new
        ),
        type = "response"
      )
    )
}
```

#### Make the plot

```{r}
hp_pd <-
  resp_p %>% 
  as_tibble(rownames = "x") %>% 
  pivot_longer(cols = starts_with("V"), names_to = "lag", names_prefix = "V", values_to = "fitted") %>% 
  mutate(lag = as.double(lag) - 1, x = as.double(x)) 

hopper_precip_contour <-
  ggplot(hp_pd, aes(x = x, y = lag, z = fitted, fill = fitted)) +
  geom_raster(interpolate = TRUE) +
  geom_contour(color = "black", alpha = 0.2) +
  scale_fill_viridis_c("Leafhoppers per leaf", option = "D") + 
  scale_y_continuous("Lag (days)", expand = c(0,0)) + 
  scale_x_continuous("Precipitation (mm)", expand = c(0,0)) +
  theme(text = element_text(size = 14))
save_plot(here("figs", "hopper_precip_contour.png"), hopper_precip_contour)
```
Low precip at 5 and 11 days ago has negative effect on leafhoppers (dessication?)

High precip has positive effect on leafhoppers

# Conclusion