---
title: "Leafhopper distributed lag model"
author: "Eric R. Scott"
date: "2020-01-25"
output: 
  html_notebook: 
    highlight: kate
    theme: yeti
    toc: yes
    toc_float: yes
    number_sections: yes
---
#TODO

- Tidy up analysis

- move wrangling out of this doc


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(scipen = 4)
```

*Last compiled: `r Sys.Date()`*

```{r packages, message=FALSE, warning=FALSE}
library(tidyverse)
library(here)
library(conflicted)
library(mgcv)
library(dlnm)
library(colorspace)
library(cowplot)
library(bbmle)
library(patchwork)

conflict_prefer("filter", "dplyr")
conflict_prefer("here", "here")
conflict_prefer("lag", "dplyr")
conflict_prefer("select", "dplyr")
```


# Goal

This analysis is based on Gasparrini A, Scheipl F, Armstrong B, Kenward MG (2017) A penalized framework for distributed lag non-linear models. Biometrics 73:938–948. doi: 10.1111/biom.12645.  Specifically, it is based on `ex1_01.int.R` provided in their code.  This "internal" method for distributed lag models takes full(?) advantage of built in features of `gam`s.

The goal is to model the effects of temperature and precipitation on leafhoppers as having a quadratic, lagged effect.  The lag is modeled as a penalized cubic regression spline and the effect of temperature as a 2nd order polynomial in a crossbasis smoother. In an ideal world, the penalized spline would be the shrinkage version (bs = "cs"), but that isn't available in the crossbasis smooth constructor provided by `dlnm`.

# Read in Data

```{r}
hoppers <- read_rds(here("data", "cleaned", "hopper-weather.rds"))

hoppers <- hoppers %>% 
  mutate(interharvest_id = as.factor(paste0(field, interharvest.no)),
         counter = as.factor(counter),
         plant = as.factor(plant)) %>% 
  filter(!is.na(precip_lag15)) #get rid of plants that don't have 15 days of data

head(hoppers)
# str(hoppers)
```


# Distributed Lag Model: "internal" method

## Setup

Create matrices for temperature, precip, and lag.

```{r}
Q_temp <-
  hoppers %>% 
  select(starts_with("temp"), -temp_at_count, -temp_max, -temp_min) %>% 
  as.matrix()

Q_precip <-
  hoppers %>%
  select(starts_with("precip")) %>% 
  as.matrix()

L <- matrix(0:(ncol(Q_temp)-1), nrow(Q_temp), ncol(Q_temp), byrow = TRUE)
```

# Build the GAMs

Temp and precip are highly concurve, so can't trust p-values. I'll do the models separately.

```{r}
m_hopper_temp <- 
  gam(hoppers ~
        s(Q_temp, L,
          bs = "cb",
          k = c(5, 7),
          xt = list(bs = "cr")
        ) +
        # s(day, bs = "cs") +
        s(day_post, bs = "cs") +
        s(counter, bs = "re") + #no difference with random vs. fixed
        s(interharvest_id, bs = "re") +
        s(plant, bs = "re"),
      family = poisson(),
      offset = log(n_leaves),
      data = hoppers,
      # gamma = 1.2, #values above 1 make smoother.  Borrowed from Teller et al.
      method = "REML")

m_hopper_precip <- 
  gam(hoppers ~
        s(Q_precip, L,
          bs = "cb",
          k = c(5, 7),
          xt = list(bs = "cr")
        ) +
        # s(day, bs = "cs") +
        s(day_post, bs = "cs") +
        s(counter, bs = "re") + #no difference with random vs. fixed
        s(interharvest_id, bs = "re") +
        s(plant, bs = "re"),
      family = poisson(),
      offset = log(n_leaves),
      data = hoppers,
      # gamma = 1.2, #values above 1 make smoother.  Borrowed from Teller et al.
      method = "REML")

m_hopper_date <- 
  gam(hoppers ~
        s(day, bs = "cs") +
        s(day_post, bs = "cs") +
        s(counter, bs = "re") + #no difference with random vs. fixed
        s(interharvest_id, bs = "re") +
        s(plant, bs = "re"),
      family = poisson(),
      offset = log(n_leaves),
      data = hoppers,
      # gamma = 1.2, #values above 1 make smoother.  Borrowed from Teller et al.
      method = "REML")
```

```{r}
anova.gam(m_hopper_date)
anova.gam(m_hopper_precip)
anova.gam(m_hopper_temp)
ICtab(m_hopper_temp, m_hopper_precip, m_hopper_date)
```

Precip model wins.

# Temperature

## Inspect the GAM

```{r}
gam.check(m_hopper_temp)
#check for overdispersion
sum(residuals(m_hopper_temp, type = "pearson")^2) / df.residual(m_hopper_temp)
```

not overdispersed

```{r}
concurvity(m_hopper_temp, full = TRUE)
# concurvity(m_hopper_temp, full = FALSE)
```

Day and temperature have high concurvity.  They are highly correlated, but correlations breaks down quickly through lag time  I'm going to include both.


## Significance test

```{r}
anova.gam(m_hopper_temp)
```

Significant effect of plant (parametric factor), temperature, precip, days post harvest, and diameter on growth.

## Predictions and plots

### Plot regular smooths of covariates

These are non-significant, so I won't include them in the paper figure.

```{r}
plot.gam(m_hopper_temp, pages = 1, residuals = FALSE, all.terms = TRUE)
```

### Partial effects plot for cross-basis function

#### Make newdata

```{r}
testvals <- seq(min(Q_temp), max(Q_temp), length.out = 200)
Q_temp_new <- matrix(mean(hoppers$temp_mean), nrow = length(testvals), ncol = ncol(Q_temp))
L_new <- L[1:length(testvals), ]
day_post_new <- rep(mean(hoppers$day_post), length(testvals))
day_new <- rep(mean(hoppers$day), length(testvals))
interharvest_id_new <- rep("newlevel", length(testvals))
plant_new <- rep("newlevel", length(testvals))
counter_new <- rep("newlevel", length(testvals))
```

#### predict loops

```{r}
resp_t <- array(dim = c(length(testvals), ncol(Q_temp_new)))
rownames(resp_t) <- testvals

#loop through columns of matrix, replace with testvals, predict fitted.
for(i in 1:ncol(Q_temp_new)) {
  P1_i <- Q_temp_new
  P1_i[, i] <- testvals
  resp_t[, i] <-
    suppressWarnings( #new levels of random effects are on purpose
      predict(
        m_hopper_temp,
        newdata = list(
          Q_temp = P1_i,
          L = L_new,
          day_post = day_post_new,
          day = day_new,
          interharvest_id = interharvest_id_new,
          plant = plant_new,
          counter = counter_new
        ),
        type = "response"
      )
    )
}

which(resp_t == max(resp_t), arr.ind = TRUE)
resp_t[1, 10, drop = FALSE]

which(resp_t == min(resp_t), arr.ind = TRUE)
resp_t[112, 16, drop = FALSE]
```

#### Make the plot

Raster version:

```{r}
ht_pd <-
  resp_t %>%
  as_tibble(rownames = "x") %>%
  pivot_longer(
    cols = starts_with("V"),
    names_to = "lag",
    names_prefix = "V",
    values_to = "fitted"
  ) %>%
  mutate(lag = as.double(lag) - 1, x = as.double(x)) 

hopper_temp_raster <-
  ggplot(ht_pd, aes(x = x, y = lag, z = fitted, fill = fitted)) +
  geom_raster(interpolate = TRUE) +
  geom_contour(color = "black", alpha = 0.2) +
  scale_fill_viridis_c("Leafhoppers \n per leaf", option = "A", limits = c(0.0348, 0.066)) + 
  scale_y_continuous("Lag (days)", expand = c(0,0)) + 
  scale_x_continuous("Temperature (ºC)", expand = c(0,0)) +
  theme(text = element_text(size = 14))
save_plot(here("figs", "hopper_temp_raster.png"), hopper_temp_raster)
```

Contour version:

```{r}
hopper_temp_contour <-
  ggplot(ht_pd, aes(x = x, y = lag, z = fitted, fill = fitted)) +
  geom_contour_filled(aes(fill = stat(level)),
                      breaks = pretty(seq(0.0348, 0.0659, 0.0001), n = 12)) + 
  scale_fill_viridis_d("Leafhoppers per leaf", option = "A", drop = FALSE) + 
  scale_y_continuous("Lag (days)", expand = c(0,0)) + 
  scale_x_continuous("Temperature (ºC)", expand = c(0,0)) +
  guides(fill = guide_colorsteps(show.limits = TRUE, barheight = unit(0.75, "npc"))) +
  theme(text = element_text(size = 14))
save_plot(here("figs", "hopper_temp_contour.png"), hopper_temp_contour)
```

Cooler temperatures are good for leafhoppers.  Little discernable effect of lag.  Not sure how to interpret

# Precip

Inspect gam:

```{r}
gam.check(m_hopper_precip)
```

```{r}
concurvity(m_hopper_precip)
# concurvity(m_hopper_precip, full = FALSE)
```


```{r}
anova.gam(m_hopper_precip)
summary(m_hopper_precip)
```

significant effect of precip, but not of date.

### Plot regular smooths for co-variates

Not significant, so these won't be in the paper

```{r}
plot(m_hopper_precip, all.terms = TRUE)
```


### Partial effects plot for cross-basis function

#### Make newdata

```{r}
m_hopper_precip
testvals <- seq(min(Q_precip), max(Q_precip), length.out = 200)
Q_precip_new <- matrix(mean(hoppers$precip_mm), nrow = length(testvals), ncol = ncol(Q_precip))
L_new <- L[1:length(testvals), ]
day_post_new <- rep(mean(hoppers$day_post), length(testvals))
day_new <- rep(mean(hoppers$day), length(testvals))
interharvest_id_new <- rep("newlevel", length(testvals))
plant_new <- rep("newlevel", length(testvals))
counter_new <- rep("newlevel", length(testvals))
```

#### predict loops

```{r}
resp_p <- array(dim = c(length(testvals), ncol(Q_precip_new)))
rownames(resp_p) <- testvals

#loop through columns of matrix, replace with testvals, predict fitted.
for(i in 1:ncol(Q_precip_new)) {
  P1_i <- Q_precip_new
  P1_i[, i] <- testvals
  resp_p[, i] <-
    suppressWarnings( #new levels of random effects are on purpose
      predict(
        m_hopper_precip,
        newdata = list(
          Q_precip = P1_i,
          L = L_new,
          day_post = day_post_new,
          day = day_new,
          interharvest_id = interharvest_id_new,
          plant = plant_new,
          counter = counter_new
        ),
        type = "response"
      )
    )
}

which(resp_p == min(resp_p), arr.ind = TRUE)
resp_p[1,16, drop = FALSE]

which(resp_p == max(resp_p), arr.ind = TRUE)
resp_p[200, 2, drop = FALSE]
```
```{r}
# at one day of lag:
which(resp_p == min(resp_p[ , 2]), arr.ind = TRUE)

```


#### Make the plot

Raster version:

```{r}
hp_pd <-
  resp_p %>%
  as_tibble(rownames = "x") %>%
  pivot_longer(
    cols = starts_with("V"),
    names_to = "lag",
    names_prefix = "V",
    values_to = "fitted"
  ) %>%
  mutate(lag = as.double(lag) - 1, x = as.double(x)) 

hopper_precip_raster <-
  ggplot(hp_pd, aes(x = x, y = lag, z = fitted, fill = fitted)) +
  geom_raster(interpolate = TRUE) +
  geom_contour(color = "black", alpha = 0.2) +
  scale_fill_viridis_c("Leafhoppers \n per leaf", option = "A", limits = c(0.0348, 0.066)) + 
  scale_y_continuous("Lag (days)", expand = c(0,0)) + 
  scale_x_continuous("Precipitation (mm)", expand = c(0,0)) +
  theme(text = element_text(size = 14))
save_plot(here("figs", "hopper_precip_raster.png"), hopper_precip_raster)
```

Contour vesrion:

```{r}
hopper_precip_contour <-
  ggplot(hp_pd, aes(x = x, y = lag, z = fitted, fill = fitted)) +
  geom_contour_filled(aes(fill = stat(level)),
                      breaks = pretty(seq(0.0348, 0.0659, 0.0001), n = 12)) + 
  scale_fill_viridis_d("Leafhoppers per leaf", option = "A", drop = FALSE) + 
  scale_y_continuous("Lag (days)", expand = c(0,0)) + 
  scale_x_continuous("Precipitation (mm)", expand = c(0,0)) +
  guides(fill = guide_colorsteps(show.limits = TRUE, barheight = unit(0.7, "npc"))) +
  theme(text = element_text(size = 14))
save_plot(here("figs", "hopper_temp_contour.png"), hopper_temp_contour)
```


Low precip at 5 and 11 days ago has negative effect on leafhoppers (dessication?)

High precip has positive effect on leafhoppers

# Alternate plot layouts

## Elizabeth's suggestion:

Combine raster plots

```{r}
hopper_cbs <- hopper_precip_raster + hopper_temp_raster + plot_layout(guide = "collect") + plot_annotation(tag_levels = "A")
save_plot(here("figs", "hopper_crossbasis.png"), hopper_cbs, ncol = 2, nrow = 1, base_asp = 1.2)
```

